/* grainc-flags --no-gc */
// Workaround until int256 (fixnum) support is added to Grain

import Int64 from "int64"
import Bytes from "bytes"

type Int256 = Bytes

export let allocate = () => {
  let ret = Bytes.make(32)
  Bytes.fill(0l, ret)
  ret: Int256
}

export let toBytes: Int256 -> Bytes = identity
export let fromBytes: Bytes -> Int256 = identity

export let fromInt64: Int64 -> Int256 = n => {
  let ret = allocate()
  Bytes.setInt64(0, n, ret)
  ret
}

export let lt = (a: Int256, b: Int256) => {
  let aBytes = a
  let bBytes = b
  let mut res = false
  for (let mut i = 3; i >= 0; i -= 1) {
    let aPiece = Bytes.getInt64(i * 8, aBytes)
    let bPiece = Bytes.getInt64(i * 8, bBytes)
    if (Int64.ltU(aPiece, bPiece)) {
      res = true
      break
    }
  }
  res
}

export let lte = (a: Int256, b: Int256) => {
  a == b || lt(a, b)
}

export let gt = (a: Int256, b: Int256) => {
  let aBytes = a
  let bBytes = b
  let mut res = false
  for (let mut i = 3; i >= 0; i -= 1) {
    let aPiece = Bytes.getInt64(i * 8, aBytes)
    let bPiece = Bytes.getInt64(i * 8, bBytes)
    if (Int64.gtU(aPiece, bPiece)) {
      res = true
      break
    }
  }
  res
}

export let gte = (a: Int256, b: Int256) => {
  a == b || gt(a, b)
}

export let add = (a: Int256, b: Int256) => {
  let aBytes = a
  let bBytes = b
  let retBytes = Bytes.make(32)
  let mut res = false
  let mut carry = 0L
  for (let mut i = 3; i >= 0; i -= 1) {
    let aPiece = Bytes.getInt64(i * 8, aBytes)
    let bPiece = Bytes.getInt64(i * 8, bBytes)
    let retPiece = Int64.add(Int64.add(aPiece, bPiece), carry)
    if (Int64.ltU(retPiece, aPiece)) {
      carry = 1L
    } else {
      carry = 0L
    }
    Bytes.setInt64(i * 8, retPiece, retBytes)
  }
  retBytes: Int256
}

export let sub = (a: Int256, b: Int256) => {
  let aBytes = a
  let bBytes = b
  let retBytes = Bytes.make(32)
  let mut res = false
  let mut carry = 0L
  for (let mut i = 3; i >= 0; i -= 1) {
    let aPiece = Bytes.getInt64(i * 8, aBytes)
    let bPiece = Bytes.getInt64(i * 8, bBytes)
    let retPiece = Int64.sub(Int64.sub(aPiece, bPiece), carry)
    if (Int64.gtU(retPiece, aPiece)) {
      carry = 1L
    } else {
      carry = 0L
    }
    Bytes.setInt64(i * 8, retPiece, retBytes)
  }
  retBytes: Int256
}
